

public class InsertionSort01 { // 삽입 정렬을 이용해 주어진 배열 정렬하기(오름차순)

	public static void main(String[] args) {

		int i, j, temp;

		int array[] = { 1, 10, 5, 8, 7, 6, 4, 3, 2, 9 }; // 원소의 갯수가 10개인 배열

		// 주어진 배열 출력
		System.out.print("주어진 배열: ");
		for (i = 0; i < 10; i++) {
			System.out.printf("%d ", array[i]);
		}

		// 삽입 정렬을 이용해 정렬
		for (i = 0; i < 9; i++) {
			j = i; // 현재 정렬할 원소 선택
			while (array[j] > array[j + 1]) {
				temp = array[j];
				array[j] = array[j + 1];
				array[j + 1] = temp;
				j--;
			}
		}

		// 새로 정렬된 배열 출력
		System.out.print("\n새로 정렬된 배열: ");
		for (i = 0; i < 10; i++) {
			System.out.printf("%d ", array[i]);
		}
	}

}

/*
 * 삽입 정렬의 시간복잡도
 * 
 * 10개의 원소를 가진 배열을 정렬하려면 다음과 같은 횟수의 계산이 필요하다. 
 * 10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1
 * 이러한 등차 수열을 계산하는 공식은 다음과 같다. => N*(N+1)/2
 * 10*(10+1)/2=55
 * 따라서 원소의 갯수가 10개인 배열은 총 55번의 연산을 수행하게 된다. 
 * 
 * 따라서 삽입정렬의 복잡도는 O(N^2)와 같다. 
 * 
 * 복잡도는 선택정렬과 동일하지만, 
 * 선택 정렬의 경우, 왼쪽에 있는 숫자들은 정렬되어있다고 가정하기에, 
 * 비교하며 자기 자리를 찾을 경우, 끝까지 비교하지 않고, 비교를 멈춘다. 
 * 따라서 삽입정렬은 선택정렬이나 버블 정렬에 비해 더 효율적이다. 
 * 
 * 거의 정렬된 상태의 배열을 정렬할때야 말로 삽입정렬이 가장 빠른데, 
 * 2 3 4 5 6 7 8 9 10 1 
 * 이 주어진다면, 10까지 오기까지 굉장히 빠른 연산이 수행되고, 1까지 와야  swap이 이루어진다. 
 * 삽입 정렬은 필요할 때에 한해서만 삽입을 진행하기 때문에 데이터가 이미 거의 정렬된 상태에 한해서는 
 * 어떤 알고리즘보다도 빠르다는 특징을 가진다. 
 * 
 * */